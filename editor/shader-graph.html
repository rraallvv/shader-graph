<dom-module id="shader-graph">
	<link rel="import" type="css" href="css/bootstrap.css">
	<link rel="import" type="css" href="css/graph.css">
	<link rel="import" type="css" href="css/preview.css"/>

	<template>
		<div id="content" class="container-full">loading...</div>
	</template>

	<script src="js/external/jsplumb.js"></script>
	<script src="js/external/react.js"></script>
	<script src="js/external/react-dom.js"></script>
	<script src="js/external/require.js"></script>
	<script src="js/external/cocos2d-js.js"></script>
	<script src="js/external/glsl-optimizer-init.js"></script>
	<script src="js/external/glsl-optimizer.js"></script>
	<script src="../build/shadergraph.js"></script>
	<script src="js/editor.js"></script>

	<!--<script type="text/babel">-->
	<script>
		if ( typeof Editor === "undefined" ) {
			window.Editor = { polymerElement: Polymer, log: console.log };
		}

		var Preview = React.createClass({
			_CCSettings: {
				"platform": "web-desktop",
				"groupList": [
					"default"
				],
				"collisionMatrix": [
					[
						true
					]
				],
				"rawAssets": {
					"assets": {
						"cd0305b4-c877-43af-8ed8-27d38478c262": [
							"Images/monkey",
							"cc.SpriteFrame",
							1
						],
						"1d955528-ab82-4be4-a727-d864908c2b74": [
							"Images/monkey.png",
							"cc.Texture2D"
						],
						"ecbfd2e4-3595-4b9e-94e1-ad307f36bfab": [
							"resources/EffectPreview.fs.glsl",
							"cc.RawAsset"
						],
						"2fdfd899-b375-46c6-ac69-fdefaf994017": [
							"resources/EffectPreview_noMVP.vs.glsl",
							"cc.RawAsset"
						],
						"0bf9ac5e-ff33-4a0a-9de7-83bff3b29a40": [
							"resources/EffectPreview.vs.glsl",
							"cc.RawAsset"
						]
					},
					"internal": {
					}
				},
				"launchScene": "db://assets/Scene/EffectPreview.fire",
				"scenes": [
					{
						"url": "db://assets/Scene/EffectPreview.fire",
						"uuid": "0c0e54e8-a57a-4811-af7d-e0106440f9f2"
					}
				],
				"orientation": "",
				"debug": false
			},
			componentDidMount: function(){
				if (cc.sys.isBrowser) {
					this._initEngine();
				}
				else if (cc.sys.isNative) {
					require('js/settings.js');
					require('js/jsb_polyfill.js');

					this._initEngine();
				}
			},
			_initEngine: function() {
				if ( !this._CCSettings.debug ) {
					// retrieve minified raw assets
					var rawAssets = this._CCSettings.rawAssets;
					var assetTypes = this._CCSettings.assetTypes;
					for (var mount in rawAssets) {
						var entries = rawAssets[mount];
						for (var uuid in entries) {
							var entry = entries[uuid];
							var type = entry[1];
							if (typeof type === 'number') {
								entry[1] = assetTypes[type];
							}
						}
					}
				}

				// init engine
				var canvas, div;
				//var width = 640, height = 480;

				if (cc.sys.isBrowser) {
					canvas = document.getElementById('GameCanvas');
					div = document.getElementById('GameDiv');

					//width = div.clientWidth;
					//height = div.clientHeight;
				}

				function setLoadingDisplay () {
					// Loading splash scene
					var splash = document.getElementById('splash');
					var progressBar = splash.querySelector('.progress-bar span');
					var currentResCount = cc.loader.getResCount();
					cc.loader.onProgress = function (completedCount, totalCount, item) {
						var percent = 100 * (completedCount - currentResCount) / (totalCount - currentResCount);
						if (progressBar) {
							progressBar.style.width = percent.toFixed(2) + '%';
						}
					};
					splash.style.display = 'block';

					cc.director.once(cc.Director.EVENT_AFTER_SCENE_LAUNCH, function () {
						splash.style.display = 'none';
					});
				}

				var onStart = function () {
					cc.view.resizeWithBrowserSize(true);
					// UC browser on many android devices have performance issue with retina display
					if (cc.sys.os !== cc.sys.OS_ANDROID || cc.sys.browserType !== cc.sys.BROWSER_TYPE_UC) {
						cc.view.enableRetina(true);
					}
					//cc.view.setDesignResolutionSize(this._CCSettings.designWidth, this._CCSettings.designHeight, cc.ResolutionPolicy.SHOW_ALL);
				
					if (cc.sys.isBrowser) {
						setLoadingDisplay();
					}

					if (this._CCSettings.orientation === 'landscape') {
						cc.view.setOrientation(cc.macro.ORIENTATION_LANDSCAPE);
					}
					else if (this._CCSettings.orientation === 'portrait') {
						cc.view.setOrientation(cc.macro.ORIENTATION_PORTRAIT);
					}

					// init assets
					cc.AssetLibrary.init({
						libraryPath: shaderGraph.resolveUrl('res/import'),
						rawAssetsBase: shaderGraph.resolveUrl('res/raw-'),
						rawAssets: this._CCSettings.rawAssets
					});

					var launchScene = this._CCSettings.launchScene;

					var self = this;

					// load scene
					cc.director.loadScene(launchScene, null,
						function () {
							if (cc.sys.isBrowser) {
								// show canvas
								canvas.style.visibility = '';
								var div = document.getElementById('GameDiv');
								if (div) {
									div.style.backgroundImage = '';
								}
							}

							// play game
							// cc.game.resume();

							cc.eventManager.addCustomListener("preview_did_load", function(event){
								cc.eventManager.removeCustomListeners("preview_did_load");
								setTimeout(function(){ self.updateShader(); }, 1000);
							});

							console.log('Success to load scene: ' + launchScene);
						}
					);

					// purge
					//noinspection JSUndeclaredVariable
					this._CCSettings = undefined;
				};

				var option = {
					//width: width,
					//height: height,
					id: 'GameCanvas',
					scenes: this._CCSettings.scenes,
					debugMode: this._CCSettings.debug ? cc.DebugMode.INFO : cc.DebugMode.ERROR,
					showFPS: this._CCSettings.debug,
					frameRate: 60,
					jsList: [
						shaderGraph.resolveUrl('js/preview.js')
					],
					groupList: this._CCSettings.groupList,
					collisionMatrix: this._CCSettings.collisionMatrix
				};

				cc.game.run(option, onStart.bind(this));
			},
			render: function() {
				this.updateShader();

				return React.createElement('div', null,
					React.createElement('div', {id:"GameDiv", style:{width: "226px", height: "226px"}, className:"style-scope shader-graph"},
						React.createElement('canvas', {id:"GameCanvas", width:"226px", height:"226px", className:"style-scope shader-graph"}),
						React.createElement('div', {id:"splash", className:"style-scope shader-graph"},
							React.createElement('div', {className:"progress-bar stripes style-scope shader-graph"},
								React.createElement('span', {style:{width: "0%"}, className:"style-scope shader-graph"})
							)
						)
					)
				);
			},
			updateShader: function(){
				var shaderDef = this.props.shader.buildShader();

				// console.log(shaderDef.fshader());
				if (cc.EffectPreview) {
					var fs = shaderDef.fshader();
					//fs = fs.split("uniform sampler2D texture12;").join("");
					fs = fs.split("texture12").join("CC_Texture0");

					console.log(ShaderGraph.Beautify(
						//optimize_glsl(fs, "2", "fs"),
						fs,
						{
							"indent_size": 1,
							"indent_char": '\t',
							"max_preserve_newlines": -1,
							"brace_style": "expand",
							"wrap_line_length": 0
						}
					));

					cc.EffectPreview.frag_glsl = fs;
					cc.EffectPreview.updateShader();
				}
			}
		});

		var shaderGraph;

		Editor.polymerElement({
			ready: function(){
				shaderGraph = this;
				shaderGraph._appInstance = ReactDOM.render(React.createElement(App), shaderGraph.$.content);

				/*
				// build the list of nodes
				var sidebar = Polymer.dom(document.getElementById("sidebar"));
				var items = shaderGraph.nodeList();
				for (var i = 0; i < items.length; i++) {
					var item = items[i];
					item.className = "list-group-item add-node-button";
					sidebar.appendChild(item);
				}
				*/

				//*
				var nodes = [
					{type:"value", pos:[0, 0], value:70},
					{type:"uv", pos:[0, 100]},
					{type:"value", pos:[0, 220], value:35},
					{type:"value", pos:[0, 320], value:0.5},
					{type:"multiply", pos:[200, 50]},
					{type:"multiply", pos:[200, 150]},
					{type:"cos", pos:[350, 50]},
					{type:"sin", pos:[350, 150]},
					{type:"join", pos:[500, 100]},
					{type:"value", pos:[300, 300], value: 1}
				];
				var links = [
					[2, 6],
					[3.1, 6.1],
					[3.2, 7],
					[4, 7.1],
					[6, 8],
					[7, 9],
					[8, 10],
					[9, 10.1],
					[5, 10.2],
					[11, 10.3],
					[10, 1]
				];
				//*/
				/*
				var nodes = [
					{type:"fragColor", pos:[660, 200]},
					{type:"texture", pos:[0, 0]},
					{type:"split", pos:[0, 170]},
					{type:"add", pos:[135, 90]},
					{type:"add", pos:[267, 90]},
					{type:"divide", pos:[400, 90]},
					{type:"value", pos:[250, 175], value:3},
					{type:"join", pos:[530, 170]}
				];
				var links = [
					[2, 3],
					[3, 4],
					[3.1, 4.1],
					[4, 5],
					[3.2, 5.1],
					[5, 6],
					[7, 6.1],
					[6, 8],
					[6, 8.1],
					[6, 8.2],
					[3.3, 8.3],
					[8, 1]
				];
				//*/

				for (var i = 0; i < nodes.length; i++) {
					shaderGraph._appInstance.addNode(nodes[i]);
				}

				for (var i = 0; i < links.length; i++) {
					shaderGraph._appInstance.connect(links[i][0], links[i][1]);
				}
			},
			nodeList: function() {
				return shaderGraph._appInstance.nodeTypes().map(function (type) {
					var item = document.createElement("a");
					item.type = item.innerHTML = type;
					return item;
				});
			},
			addNode: function(e) {
				var b = graph.querySelector("#canvas").getBoundingClientRect();
				var pos = e.pos || [0, 0];
				pos[0] -= b.left;
				pos[1] -= b.top;
				e.pos = pos;
				shaderGraph._appInstance.addNode(e);
			},
			setTransform: function( s, r, n, t ){
				// s = 1, r = 1, n = 0, t = 0;
				this.style.transform = "matrix(" +
					s + ", 0, 0, " +
					r + ", " +
					Math.round(n + 0.5 * this.offsetWidth * (s - 1)) + ", " +
					Math.round(t + 0.5 * this.offsetHeight * (r - 1)) + ")";
			}
		});
	</script>
</dom-module>
